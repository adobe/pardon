---
# Copyright 2024 Adobe. All rights reserved.
# This file is licensed to you under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License. You may obtain a copy
# of the License at http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software distributed under
# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
# OF ANY KIND, either express or implied. See the License for the specific language
# governing permissions and limitations under the License.

title: Pardon Tech - Template Schemas
description: A more technical overview of the template engine.
next: false
---

import { FlexyCodeGrid } from '@components';
import '@components/inline-icon.pcss';
import { Icon } from '@astrojs/starlight/components';

In the intro documentation, we cover templates and schemas from
the user's perspective.  Here we will cover the schema system from the
perspective of the maintainer.

Schemas are the live-object representation of the composition of multiple templates,
and can represent more than a single template alone.  The common example of this is
merging the template `string("{{a}}")` with the template `string("x")`.
which renders to `"x"` and also resolves the value of `a`.

Schemas are often composed of other schemas: for instance the code/data for an schema
of a json object basically holds an object of schemas.  Most schemas
are concerned with delgating values around, with the scalar schema doing
the work of handling values themselves.

As an example, let's use A <span class="inline-icon"><Icon name="random" /></span> B indicate merging the template 
A into the schema B.

For brevity, we'll use `v(x)` to indicate a scalar value that
has seen `x` as a pattern.  E.g., `v("{{x}}")` is a
scalar value for the pattern `"{{x}}"`.

Merging the value 7 into this value produces a template value
that is the combination of both:
<FlexyCodeGrid centered initial>
```json
7
```
<Icon name="random"/>
```json
v("{{x}}")
```
<Icon name="right-arrow"/>
```json
v("{{x}}", 7)
```
</FlexyCodeGrid>

A schema representing an `object({...})`
would delegate the merge operation to each of its fields,
(if it had them).

<FlexyCodeGrid centered initial>
```json
{ 
  a: 1,
  b: 2,
  c: 3
}
```
<Icon name="random"/>
```json
object({
  a: v("{{a}}"),
  b: v("{{b}}")
})
```
<FlexyCodeGrid column>
<FlexyCodeGrid initial>
<Icon name="right-caret"/>
```json
1
```
<Icon name="random"/>
```json
"{{a}}"
```
</FlexyCodeGrid>
<FlexyCodeGrid initial>
<Icon name="right-caret"/>
```json
2
```
<Icon name="random"/>
```json
"{{b}}"
```
</FlexyCodeGrid>
<FlexyCodeGrid initial>
<Icon name="right-caret"/>
```json
3
```
<Icon name="random"/>
```json
...?...
```
</FlexyCodeGrid>
</FlexyCodeGrid>
<Icon name="right-arrow"/>
```json
object({
  a: v("{{a}}", 1),
  b: v("{{b}}", 2),
  c: v(3)
})
```
</FlexyCodeGrid>

In the code, schemas are represented as functions that return objects with methods, there are three
methods which all schemas support: **scope**, **match**, and **render**, and all of
them provide other methods as needed to identify themselves and/or expose their representation.

At the minimum, a schema should be able to
- **merge** - with a value, producing another schema that incorporates that value
- **render** - producing a value compatible with its representation.

(**scope** is a pre-operation for both the merging and rendering operations).

A schema often should be able to **merge** with its own kind,
since it can break apart / understand its own representation.

We don't expect to be able to merge a scalar schema with another 
kind of schema like an array or object, because that makes no sense
in most cases.

## Types of Schema Nodes

The core schema node types are

 - **scalars** (strings, numbers, booleans and null)
 - **objects** and **arrays**
  - **keyed** / **keyed.mv** represent arrays as objects so they can be merged with more data.
 - **mix** / **mux** change the context mode.
 - **trampolines** is an implementation detail for delaying the evaluation of schemas.
 - **reference** captures any value/node in a schema.
 - **encodings** base64/json/etc... transforms data between formats.

Scalars are actually pretty involved, because of patterns and the interaction of
defining and/or declaring values used via scripts.

Arrays have many options, because the rules to define and merge arrays
are context-dependent.  Sometimes an array of length=1 is an array of length 1, and sometimes it's 
a template for all the elements of the array. (depending on the context mode)
Keyed schemas adapt arrays to objects.

Mix and mux schemas change the context's match mode for the current template.  since
values are evaluated in scripts inside-out but mix and mux apply changes outside-in, trampolines
exist to invert control.

Another important core schema type is reference that binds a value to any schema node,
and stub nodes exist as undefined nodes that can become anything through matching.

:::note
Schemas should be immutable.  Match operations return new schemas, any
non-immutable state should go into the context runtime scope.
:::

## Schema Operations

Schemas must not only describe their own structure (I am a string, an object, an array)...
they must also declare their named values (values declared in patterns).

Schemas operations flow context through them, transforming that context contextually.
Contexts have a key path, and also a scope.  For example, in the schema produced
from this template,
```json
{
  x: { a: "{{a}}" },
  y: { a: "{{a2}}" },
  c: "{{c}}"
}
```
the values `a` and `a2` (and `c`) are all the same scope.

In contrast, an array template like `[{ a: "{{x}}" }]` creates
a scope for each item, so that merging (matching) an array into
a array schema works roughly as follows.
<FlexyCodeGrid centered>
```json
[
  { a: 1 },
  { a: 2 }
]
```
<Icon name="random"/>
```json
array(
  array={
    a: v("{{x}}")
  }
)
```
<Icon name="right-arrow" />
```json
array(
  array=[
    { a: v("{{x}}", 1) },
    { a: v("{{x}}", 2) }
  ]
)
```
</FlexyCodeGrid>

The definition of schema is a function returning an object with various operations.

The three core operations all schemas support are

- **merge** - matches or merges the schema against a template or value, producing another schema (or `undefined` on a failed match.)
- **render** - renders a schema back into plain data.
- **scope** - scopes out the schema node... registering declarations and definitions into the template runtime scope.

Additional methods are schema-defined, such as the object schema type
having an additional method
- **object** - returns the object of schemas for the fields.
etc...

The three main merge modes are
 - _mix_ - which integrates schema templates,
 - _mux_ - which integrates value templates, and
 - _match_ - which applies the schema to data (and only data).

A primary difference between _mix_ and _mux_ is how arrays are handled,
when mixing in a single-length array, the value is treated as a schema for
all the items in the array, but when _mux_{}ing in a single length array,
the value is treated as a template for an array of one element.

The _match_ mode is applied to data, not templates, so when matching,
even values like `"{{t}}"` should be treated a literal data (not a pattern),
also single-length arrays are not treated as item templates, etc...

The **render** operation is used to create a value.  It can be a full render
or a preview render (useful for previewing or debugging the structure of a
schema without evaluating any of the scripts).  Some other render modes are optimized
for other edge cases.

The **scope** operation is called both pre-**merge** and pre-**render** and is responsible
for setting up the context's scope structure.  The scope structure is how
Pardon figures out the correct order to resolve or evaluate dependent values
regardless of where they are in request.

The **merge** operation is synchronous and intended to be relatively fast.
In contrast the **render** operation is asynchronous
as it [potentially depends on](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)
async script evaluation.

## Schema Encodings

Schema nodes can also represent various encodings of data.

For instance... we can have a schema like

```js
base64(json(object({
  hello: v("{{hello}}")
})))
```

which accepts some base64 input, translates it to text, and then
json takes that text, parses it as JSON, and matches that into
the `$decoded` collector.

So this template would extract the decoded value into a javascript object.

If we pass `"eyJoZWxsbyI6IndvcmxkIn0K"` into this schema, first the base64 would
parse into text.
<FlexyCodeGrid centered initial>
```json
"eyJoZWxsbyI6IndvcmxkIn0K"
```
<Icon name="random" />
```js
base64(json(object({
  hello: v("{{hello}}")
})))
```
</FlexyCodeGrid>

this text would be delegated to the json format schema node.
<FlexyCodeGrid centered initial>
```js
'{"hello":"world"}'
```
<Icon name="random" />
```js
json(object({
  hello: v("{{hello}}")
}))
```
</FlexyCodeGrid>

Next the json object itself matches with the object schema, and so on
through to the `hello` field.

<FlexyCodeGrid column>
<FlexyCodeGrid initial>
```js
{
  hello: "world"
}
```
<Icon name="random" />
```js
object({
  hello: v("{{hello}}")
})
```
</FlexyCodeGrid>
<FlexyCodeGrid initial centered>
<Icon name="right-caret" />
```js
"world"
```
<Icon name="random" />
```js
v("{{hello}}")
```
<Icon name="right-arrow" />
```js
v("{{hello}}", "world")
```
</FlexyCodeGrid>
<FlexyCodeGrid initial right>
<Icon name="right-arrow" />
```js
object({
  hello: v("{{hello}}", "world")
})
```
</FlexyCodeGrid>
</FlexyCodeGrid>

This will get rewrapped with the format so the overall behavior of matching
`"eyJoZWxsbyI6IndvcmxkIn0K"` into our schema is magic.

<FlexyCodeGrid centered>
```json
"eyJ..0K"
```
<Icon name="random" />
```js
base64(json(object({
  hello: v("{{hello}}")
})))
```
<Icon name="right-arrow" />
```js
base64(json(object({
  hello: v("{{hello}}", "world")
})))
```
</FlexyCodeGrid>

Schema encodings are one of the schema types that generally need to supporting merging with themselves,
so `base64(x)` and `base64(y)` will merge as `base64(x merge y)`, etc...
