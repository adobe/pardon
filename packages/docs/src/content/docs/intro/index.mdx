---
# Copyright 2025 Adobe. All rights reserved.
# This file is licensed to you under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License. You may obtain a copy
# of the License at http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software distributed under
# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
# OF ANY KIND, either express or implied. See the License for the specific language
# governing permissions and limitations under the License.

title: Introduction to Pardon
description: An interactive tour of how Pardon works
server: todo
prev: false
next: false
---

import {
  Card,
  Icon,
  Tabs,
  TabItem,
} from '@astrojs/starlight/components';
import {
  CollectionLinkCard,
  Exercises,
  ExerciseItem,
  PardonPlayground,
  FlexyCodeGrid
 } from '@components';
import todoService from '@pardon/todo-service.ts'

Pardon is a polite http framework that allows users to be pert.

Pardon is a template processor:
templates are used to describe, match, format, extend, and parse
http requests and http responses.
Templates are written in a dialect of the "HTTP format", mostly patterned on the plain-text
format of HTTP/1.1.

Templates supply the forgettable details of your http exchanges.
Who would remember to add a Content-Type header when they're focused on the actual content?

Authorization tokens? Request signing? Switching environments?
All easily done in Pardon.

## A quick tour

Let's consider the requests for the backend of a simple multi-user todo-style application.

- The API manages users and todos.
- The login API exchanges password-based authentication for a bearer token.
- Logged in users can edit their todo list (create, read, update, delete, and list). 
- Todo objects have a "task" (description) and a "done" flag.

Please familiarize yourself with the following 8 requests to manage users and todos.

<div class="code-tabs"><Tabs>
  <TabItem label="/users">
    <div class="tab-subtitle">manage users</div>
    <Tabs>
      <TabItem label="POST (create)">
        Create a user

        ```http
        POST https://todo.example.com/users
        Content-Type: application/json

        {
          "username": "{{username}}",
          "password": "{{@password}}"
        }
        ```
      </TabItem>
      <TabItem label="PUT (login)">
        Returns an authorization token that identifies the user

        ```http
        PUT https://todo.example.com/users
        Content-Type: application/json

        {
          "username": "{{username}}",
          "password": "{{@password}}"
        }
        ```
      </TabItem>
      <TabItem label="DELETE">
        Delete a user

        ```http
        DELETE https://todo.example.com/users
        Authorization: User {{@token}}
        ```
      </TabItem>
    </Tabs>
  </TabItem>

  <TabItem label="/todos">
    <div class="tab-subtitle">the todo list</div>
    <Tabs>
      <TabItem label="POST (add a todo)">
        Create a new todo

        ```http
        POST https://todo.example.com/todos
        Authorization: User {{@token}}
        Content-Type: application/json

        {
          "task": "{{?task}}",
          "done": "{{?done}}"
        }
        ```
      </TabItem>
      <TabItem label="GET (list)">
        Get all the todos for a user

        ```http
        GET https://todo.example.com/todos
        Authorization: User {{@token}}
        ```
      </TabItem>
    </Tabs>
  </TabItem>
  <TabItem label="/todos/{{todo}}">
    <div class="tab-subtitle">manage a todo</div>
    <Tabs>
      <TabItem label="GET">
        Get the state of a single todo

        ```http
        GET https://todo.example.com/todos/{{todo}}
        Authorization: User {{@token}}
        ```
      </TabItem>
      <TabItem label="PUT (update)">
        Update a todo

        ```http
        PUT https://todo.example.com/todos/{{todo}}
        Authorization: User {{@token}}
        Content-Type: application/json

        {
          "task": "{{?task}}",
          "done": "{{?done}}"
        }
        ```
      </TabItem>
      <TabItem label="DELETE">
        Delete a todo

        ```http
        DELETE https://todo.example.com/todos/{{todo}}
        Authorization: User {{@token}}
        ```
      </TabItem>
    </Tabs>
  </TabItem>
</Tabs></div>

A pardon collection would contain the above templates inside `.https` files,
or "HTTP-schema" files of request and response templates.
{/* Yes, I'm quite proud of myself for that name, thanks for asking  */}

Response templates extract and redact values in a response,
for example, here the user login HTTP schema specifies a 
field to redact in the response:

```http
>>>
PUT https://todo.example.com/users
Content-Type: application/json

{
  "username": "{{username}}",
  "password": "{{@password = secrets.password}}"
}

<<<
200 OK

{
  "token": "{{@token}}"
}
```

The `{{@token}}` here is important for two reasons, primarily it identifies the
field as a secret which masks it in logs, but also a script can use the
extracted value when using `pardon()`'s Javascript API to access the authorization call.

Here's what that script might look like:

```ts
import { pardon } from "pardon";

export async function authorizeUser(username) {
  const {
    ingress: { response: res, secrets: { token } },
  } = await pardon({ username })`
    PUT https://todo.example.com/users
  `();

  if (!token) {
    throw new Error(
      `failed to authorize user ${username}: (${res.status}) ${res.body}`,
    );
  }

  return token;
}
```

### Demo

Using our todo API, we can get a feel for how Pardon works.

We will go through some basic flows.
 - create a user.
 - create a todo item.
 - mark the todo as completed.

In this interactive tutorial, switching between the following tabs updates the request.
(You will need to run each tab's request before the next one.)

<PardonPlayground secrets response id="todo-playground" example={`
username=test
@password=pw
POST https://todo.example.com/users
`} {...todoService}>

 <Tabs>
   <TabItem label="1. register">
    Register a new user, with a password.

    ```http copy=playground clear=todo autocopy
    @password=pw
    POST https://todo.example.com/users
    ```
   </TabItem>
   <TabItem label="2. create todo">
    Create a todo for your user.

    ```http copy=playground clear=password,@password,todo autocopy
    POST https://todo.example.com/todos

    {
      "task": "learn to use pardon"
    }
    ```
  </TabItem>
  <TabItem label="3. mark todo completed">
    Mark your todo item, done.

    ```http copy=playground clear=password,@password autocopy
    PUT https://todo.example.com/todos/{{todo}}

    {
      "done": true
    }
    ```
  </TabItem>
</Tabs>
</PardonPlayground>

Let's go over what we just did.

First we created a user with name "test" using input values.
The `@password` is a secret input, Pardon won't save this directly
in the request history.

<FlexyCodeGrid>
```http {1,2} del="Â·" title="input"
username=test
@password=pw
POST https://todo.example.com/users
```
```http '"test"' '"pw"' title="request"
POST https://todo.example.com/users
content-type: application/json

{
  "username": "test",
  "password": "pw"
}
```
</FlexyCodeGrid>

This requests tells the server-emulator in this page to register the user.

The full https schema for the create user endpoint includes a response matcher
and a post request script.  The response matcher assures that the script is only
run if the call was successful. What it does is register the `password` for the user
in the context of the value of `{ username }`.

Assigning secrets allows the `secrets.password` expression
in the `login` script to retrieve the password.

```http
>>>
POST https://todo.example.com/users
Content-Type: application/json

{
  username: "{{username}}",
  password: "{{@password}}"
}

<<<
200

!!!
secrets({ username }).password = password
```

Now that the user is created and the password is stored, we moved on to creating a todo.

If you navigate back to that second request and unlock the
secrets for viewing, you will see

```http ins={2}
POST https://todo.example.com/todos
authorization: User jwt.eyJ1c2VybmFtZSI6InRlc3QifQ==
content-type: application/json

{
  "task": "learn pardon"
}
```
while this authorization token is just `{"username":"test"}` in base64, it is being
generated from the login call.

The todo create call has the following schema:

```http {1-3} /[{]{2}@.*[}]{2}/
import:
  ./authorization.ts:
    - authorizeUser
>>>
POST https://todo.example.com/todos
Content-Type: application/json
Authorization: User {{@token = authorizeUser(username)}}

{
  task: "{{task}}",
  done: "{{?done}}"
}

<<<
200

{
  "id": "{{+todo}}"
}
```

At the top, we see a yaml-format configuration section.  Configuration can provide defaults,
runtime (or "render-time") values for the templates, imports from scripts, and environment configuration.

Here the configuration is importing the method used in the template, `{{@token = authorizeUser({ username, origin })}}`,
when we render this request, the result of running `authorizeUser({ username, origin })` is interpolated here.
Since the collection is in control of this script, practically any authorization mechanism can be supported
(read from a file, execute a local process, etc...).

Looking at the request and response, we can see that some of the variables have "hints":
The plain `{{task}}` is mandatory input, and the request will not render without it.
However, the `{{?done}}` is marked optional by the `?`-mark, if the value is not supplied
pardon can omimt the entire field.

In the response, the `+` in `{{+todo}}` marks a dataflow output,
this is why the `todo=T1001` was added automatically for the next request.

Feel free to explore the other rest calls, listing todos,
deleting todos and/or users, by editing the request input.

Here are some ideas for exploration:

<Tabs>
  <TabItem label="alternate styles">
    Try using input values in the template, instead of the request body.
    ```http copyable
    username=test
    done=true
    PUT https://todo.example.com/todos/T1001
    ```
  </TabItem>
  <TabItem label="auth">
    Try the authorization request.
    
    - Notice how Pardon adds the password
      (use the lock to toggle showing the value).
    - Try overriding it in the request and seeing how that works for you.
      (Then try overriding it the _other_ way.)

    ```http
    PUT https://todo.example.com/users
      
    { username: "test" }
    ```
  </TabItem>
  <TabItem label="extending the request">
    Try adding query params, headers, or more fields
    to the request body.  Pardon incorporates these additions
    while still applying templates.

    Try adding `"parameterized": "{{value}}"` fields
    and then specify `value=...` above the request.
  </TabItem>
</Tabs>

(Note that the saved passwords which are supplied by `secrets.password`
will be lost if the page is reloaded, you can resupply them with the login command,
just change the create user call from `POST` to `PUT`, or reset the server state).

## Next Steps

For better or worse, this tutorial only scratches the surface of Pardon's capabilities.

For more hands-on experience running pardon, where we will run the desktop
application against the same server we have in this page.

<CollectionLinkCard href="/intro/quickstart" />

For a deeper dive into the template runtime, and the programming model.

<CollectionLinkCard href="/intro/templates" />
