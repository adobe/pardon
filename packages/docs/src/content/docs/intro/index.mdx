---
# Copyright 2025 Adobe. All rights reserved.
# This file is licensed to you under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License. You may obtain a copy
# of the License at http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software distributed under
# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
# OF ANY KIND, either express or implied. See the License for the specific language
# governing permissions and limitations under the License.

title: Introduction to Pardon
description: An interactive tour of how Pardon works
prev: false
next: false
---

import {
  Card,
  Icon,
  Tabs,
  TabItem,
} from '@astrojs/starlight/components';
import {
  CollectionLinkCard,
  Exercises,
  ExerciseItem,
  IconicCode,
  PardonPlayground,
  FlexyCodeGrid
 } from '@components';
import pingExample from '@pardon/ping-example.ts'

## Why you never knew you needed another framework

Pardon works differently that most HTTP frameworks.  With other frameworks,
first the user selects a request or template to build a request.  Pardon
inverts this by selecting a compatible template from the request.

This design focuses the user on the interesting parts of the requests, and the templates
can supply all the nitty-gritty (Content-Type, Authorization, usually).

Pardon also can reconfigure requests for different environments.
For instance, Pardon can understand a request to `https://service.example.com` is production,
and `https://service-stage.example.com` is stage, and can switch between them.
Collection can specify the nominal
`https://example.com` (for legibility), but can be used in any environment.

:::note
Efforts like the OpenAPI specification do solve a subset of these issues, like
offering a choice of base URLs.  But the format is very much machine-oriented.
:::

### Focus on HTTP APIs

Requests are written in a format based on HTTP, so they are easier to understand and maintain
in any editor (or source-control) than a json-schema or other proprietary format.

Both requests and request templates share the same HTTP language.

## Demo time

Let's explore a more concrete example. Consider an `example.com/ping` API that

 - also has a stage environnment, `stage.example.com`,
 - requires an explicit `Accept` header,
 - and needs an environment-specific `apikey`.

This `ping.https` endpoint template describes that call.

```http title="example/ping.https"
config:
  origin:
    env:
      prod: https://example.com
      stage: https://stage.example.com
>>>
GET https://example.com/ping
Accept: text/plain
api-key: {{ apikey = (env === "prod" ? "system" : "staging") }}
```

This is a configuration section and then an http request template (after the `>>>`),
the template is interpretted by parsing it and then merging it into the following structure:

<FlexyCodeGrid centered>
```json
{
  "method": "GET",
  "origin": "https://example.com",
  "pathname": "/ping",
  "headers": [
    ["accept", "text/plain"],
    ["api-key", "{{ apikey = ... }}"]
  ]
}
```
```js
{
  method: "{{method}}",
  origin: "{{origin}}",
  pathname: "{{pathname}}",
  searchParams: ...,
  headers: ...,
  body: ...
}
```
</FlexyCodeGrid>

Where patterns (`"{{method}}"`) merge with values (`"GET"`), Pardon resolves the value of`method` to equal `GET`.

The `config` map in the configuration section teaches Pardon about the `env=stage` and `env=prod` environments,
associating the two values of `{{origin}}` to those environments, and vice-versa.

Using this template, the input request (which we call the "ask"), can be as simple as
"https://example.com/ping" or "https://stage.example.com".
For safety, pardon will assume an unspecified method is `GET` and, finding
only one template compatible with such a request,
fill in all the other details to flesh out rest of the request.

For example the `pardon` command line utility can, (using only this template), generate (or make)
the full requests directly.

<Tabs>
  <TabItem label="production">
```bash title="https://example.com/ping"
% pardon https://example.com/ping
pong # from prod
```
  </TabItem>
  <TabItem label="staging">
```bash frame="terminal" title="https://stage.example.com/ping"
% pardon https://stage.example.com/ping
pong # from stage
```
  </TabItem>
  <TabItem label="staging / http">
`pardon` can emit the http request (without making the call)
```bash frame="terminal" title="https://stage.example.com/ping --http"
% pardon https://stage.example.com/ping --http
GET https://stage.example.com/ping
accept: text/plain
api-key: staging
```
  </TabItem>
  <TabItem label="env=stage">
By adding `env=stage` into the request we can rewrite the ask to use stage.

Here we see the output of pardon's "`--curl`" output.
```bash frame="terminal" title="https://example.com/ping --curl env=stage"
% pardon https://example.com/ping --curl env=stage
curl "https://stage.example.com/ping" \
  --header "accept: text/plain" \
  --header "api-key: staging"
```
  </TabItem>
</Tabs>

Let's see how Pardon behaves with this collection.

With the following three exercies, you will see Pardon
expand (render) the _ask_ into the request it would send.

<PardonPlayground example="https://example.com/ping" config={pingExample}>
  <Exercises>
    <ExerciseItem label="ðŸ“–"
      prompt="interactive tutorials">
      In these tutorials, exercises are provided to guide the interaction with the playground
      shown below.  Please select the other tabs but feel free to experiment.
    </ExerciseItem>
    <ExerciseItem label='â†”'
      prompt="change the request to the stage server">
      Change the host here to to see how pardon
      automatically updates the request. (keep an eye on the `api-key` header)
      <IconicCode name="pencil">
```http ins="stage."
https://stage.example.com/ping
```
      </IconicCode>
    </ExerciseItem>
    <ExerciseItem label='?'
      prompt='add a query to the input request'>
      Pardon integrates additional query parameters to be included with requests.

      <IconicCode name="pencil">
```http ins="?hello=world"
https://stage.example.com/ping?hello=world
```
      </IconicCode>
    </ExerciseItem>
    <ExerciseItem label='+'
      prompt='add a header to the input request'>
      Pardon integrates additional headers to be included in requests.

      <IconicCode name="pencil">
```http ins={2}
https://stage.example.com/ping?hello=world
User-Agent: pardon
```
      </IconicCode>
    </ExerciseItem>
  </Exercises>
</PardonPlayground>

One more point to drive this home: this example should be factored as three separate files,
separating the concerns of service configuration (applying to all requests for the service),
the ping endpoint itself, and the (reusable!) apikey selection mixin:

<Tabs>
<TabItem label="service.yaml">
```yaml
config:
  origin:
    env:
      prod: https://example.com
      stage: https://stage.example.com
```
</TabItem>
<TabItem label="ping.https">
```http
mixin:
  - ./apikey.mix.https
>>>
GET https://example.com/ping
Accept: text/plain
```
</TabItem>
<TabItem label="apikey.mix.https">
```http
>>>
ANY //
api-key: {{ apikey = (env === "prod" ? "system" : "staging") }}
```
</TabItem>
</Tabs>

{/* --- in conclusion? --- */}

## Next Steps

To get some hands-on experience running pardon now, please try the following quickstart.

<CollectionLinkCard href="/intro/quickstart" />

To learn more of the fundamentals of Pardon's request matching and rendering system, please explore
the template guide.

<CollectionLinkCard href="/intro/templates" />
