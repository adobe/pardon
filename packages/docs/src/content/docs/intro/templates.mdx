---
# Copyright 2025 Adobe. All rights reserved.
# This file is licensed to you under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License. You may obtain a copy
# of the License at http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software distributed under
# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
# OF ANY KIND, either express or implied. See the License for the specific language
# governing permissions and limitations under the License.

title: Pardon Templates
description: A quick introduction to Pardon's templates
next: false
prev: false
---

import { Tabs, TabItem, Icon, Aside } from '@astrojs/starlight/components';
import {
  CollectionLinkCard,
  Exercises,
  ExerciseItem,
  ExerciseItemPrompt,
  CodeGrid,
  FlexyCodeGrid,
  PardonPlayground,
  TemplatePlayground
} from '@components';
import {
  productsExample,
  productsExampleWithAuth,
} from'@pardon/templates-collections'

Pardon's template engine is the foundation for how Pardon understands and builds
requests.

For the following discussion, basic understanding of programming terms is assumed.

## Templates

Templates are a novel way of structuring or destructuring data, with a
focus on JSON values, objects, and arrays with "minimal" extra syntax.

Some parts of templates represent and break down "atomic" values like numbers, strings, booleans, or `null`, while
others are suitable for representing structures like objects and arrays.  We can also use templates to manage
encodings like base64-encoded JSON.

### Interpolation Variables

There is both a string interpolation and a special javascript/typescript syntax for templating,
the javascript syntax is useful in JSON contexts like request bodies, while the interpolation syntax
is needed for other parts of the http request, like the request origin, pathname, query params and headers.

Interpolations are structured with the following pieces, _all of which are optional._

<Tabs>
  <TabItem label="name">
    <FlexyCodeGrid centered>
      ```text "?" ins="name" "= expr" "% /regex/"
      {{ ? name = expr % /regex/ }}
      ```
    </FlexyCodeGrid>
    The name identifies this interpolation: if a value is matched,... or a value is passed,... or a value
    is evaluated somewhere else.

    Names can be hyphenated (but cannot start with a hyphen.)
  </TabItem>
  <TabItem label="hints">
    <FlexyCodeGrid centered>
      ```text ins="?" "name" "= expr" "% /regex/"
      {{ ? name = expr % /regex/ }}
      ```
    </FlexyCodeGrid>
    The hint adds some flavor to how this value is processed, a `?` allows this value to be omitted,
    a `@` marks it as a secret, `...` modifies the default regex in some contexts (like in the pathname,
    to allow a value to match multiple path segments), while `-` removes a value from rendering entirely.
  </TabItem>
  <TabItem label="expr">
    <FlexyCodeGrid centered>
      ```text "?" "name" ins="= expr" "% /regex/"
      {{ ? name = expr % /regex/ }}
      ```
    </FlexyCodeGrid>
    The expression provides a default value if one is not available through matching and merging.
    Expressions can be arbitrary asynchronous javascript expressions.
  </TabItem>
  <TabItem label="regex">
    <FlexyCodeGrid centered>
      ```text "?" "name" "= expr" ins="% /regex/"
      {{ ? name = expr % /regex/ }}
      ```
    </FlexyCodeGrid>
    The regex can be used to specify exactly what values qualify for this field.
  </TabItem>
</Tabs>

We saw these in `GET https://todo.example.com/TODOS/{{todo}}`.

### Template References

In JSON bodies, references might be preferable, as they are shorter to write.  Any raw value identifier
in a JSON template is treated as a reference! For example, the POST task api in the introduction
can be represented a little more ergonomically with references, especially the `task` which appears
as a shorthand property:

<FlexyCodeGrid centered>
```http /".*",?/
POST https://todo.example.com/todos
Authorization: User {{@token}}
Content-Type: application/json

{
  "task": "{{task}}",
  "done": "{{?done}}"
}
```
```http ins="task" ins="done: done.$optional"
POST https://todo.example.com/todos
Authorization: User {{@token}}
Content-Type: application/json

{
  task,
  done: done.$optional
}
```
</FlexyCodeGrid>

For simple values, the choice to use references or interpolations is purely a stylistic one.

Expressions in the javascript syntax is "(anything in parentheses)".  For instance a default
value of `done` can be provided with:
```js
{
  done: done = (false)
}
```

This is essentially the same as an interpolated template with a default value.
```js
{
  "done": "{{done = false}}"
}
```

We can omit the "optional" hint (`?`) with this expression since there will always be a default.

<TemplatePlayground>
```
task="learn pardon"

{
  task,
  done: done = (false)
}
```
</TemplatePlayground>

The values below the dashed line are the values of any variables and references
bound by the template.

## Encodings

Sometimes values have specific encodings that can be broken down further,
for instance, you might have an APIs that takes (or returns) base64-encoded JSON strings.

Pardon can describe this with `base64(json(...))`.

<TemplatePlayground>
```
hello=world

{
  data: base64(json({ hello }))
}
```
</TemplatePlayground>

We can bind references to each step here to see what's going on, try updating the above with
`data: base64(j = json(o = { hello }))` to see the `j` and `o` values.

Encodings can also be used to extract data from encoded values!  In the following example,
we're matching the template with an already base64-encoded value, and we still get `hello=world` out.

<TemplatePlayground>
```
{
  data: base64(json({ hello }))
}
---
{ "data": "eyJoZWxsbyI6IndvcmxkIn0=" }
```
</TemplatePlayground>

## Arrays in templates

Processing arrays requires setting up a template to process multiple items.
Let's start with the template for one item:

<TemplatePlayground>
```
[
  { id, task, done }
]
---
[
  { id: "T1001", task: "hello", done: false }
]
```
</TemplatePlayground>

Adding a second value `{ id: "T1002", task: "world", done: false }`, to the data would not
work as the arrays now have different lengths.

To work around this, a template needs to specify any number of items...

<TemplatePlayground>
```
[
  ...{ id, task, done }
]
---
[
  { id: "T1001", task: "hello", done: false },
  { id: "T1002", task: "world", done: false }
]
```
</TemplatePlayground>

... using ellipsis to identify an item as a template for items in the array.

The data is now compatible with the template, but notice how no values are exported!
The values for each `id`, `task`, and `done` value 
are in the scope of each array element: there's no way to uniquely identify them.
For them to show up in the output, we need to give them a property path, `todos.id`, `todos.task` etc...

<TemplatePlayground>
```
[
  ...{ id: todos.id, task: todos.task, done: todos.done }
]
---
[
  { id: "T1001", task: "hello", done: false },
  { id: "T1002", task: "world", done: true }
]
```
</TemplatePlayground>

The `todos` value is implied to be an array of objects structured as `{ id, task, done }` elements,
so the actual data paths are `todos[0].id` or `todos[1].task` etc... 

This works in reverse as well, specifying an array of todos as input and the template:

<TemplatePlayground>
```
todos=[
  { id="T1001" task="hello" done=false }
  { id="T1002" task="world" done=true }
]

[
  ...{ id: todos.id, task: todos.task, done: todos.done }
]
```
</TemplatePlayground>

### Mapped Data

Now, as a user of this data, you might not want to have to search the array for 
a particular `id`: it would be more natural to bind this as a map.

Pardon supports this with a little syntax: `{ id: key } * [...template]`.
The first part is a template which resolves a value for `key` and then
the `todos` array is represented internally as a map based on that key.

<TemplatePlayground>
```
{ id: key } * [
  ...{ task: todos.task, done: todos.done }
]
---
[
  { id: "T1001", task: "hello", done: false },
  { id: "T1002", task: "world", done: true }
]
```
</TemplatePlayground>

This form can also be used in reverse, although in this case
we add `todos.$key` to render the id back into the list:

<TemplatePlayground>
```
todos={
  T1001={ task=hello done=false }
  T1002={ task=world done=true }
}

{ id: key } * [
  ...{ id: todos.$key, task: todos.task, done: todos.done }
]
```
</TemplatePlayground>

### Unscoped Mapped Data

Keyed arrays can also work unscoped.
For this usage, we omit the `...` example element.

<TemplatePlayground>
```
{ key } * [
  { key: "hello", value: hello },
  { key: "hi", value: hi },
]
---
hello=world
[
  { key: "hi", value: "developer" },
  { key: "extra", value: "data" },
]
```
</TemplatePlayground>

Now the values `hello` and `hi` are bound to the root scope, and can be provided as input data, or
matched.  Additional entries can be added too, so long as the key is distinct.

### Single-Item Arrays

One last feature for dealing with arrays is when we have a single element and we want to treat it as a single-item array.
This is for interoperability with the Java/Jackson `WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED` and `ACCEPT_SINGLE_VALUE_AS_ARRAY`
functionality.

We specify these in Pardon with `![...list.field]` syntax.  Consider the following template expansion

<TemplatePlayground>
```
one=[1]
two=[2,2]
{
  one: ![...one.$value],
  two: ![...two.$value],
  three: ![...three.$value],
  four: ![...four.$value],
  five: ![...five.$value]
}
---
{
  three: 3,
  four: [4],
  five: [5,5]
}
```
</TemplatePlayground>

This demonstates the following cases:

| Case | Description |
| --- | --- |
| `one` | a single item list serializes unwrapped |
| `two` | a multi-item list serializes as a list |
| `three` | an item match is rendered unwrapped |
| `four` | a single item list stays as a list |
| `five` | a multi-item list also remains as a list |

and in all cases the variable/value data is in lists.

## HTTP Templates

HTTP is parsed before being matched into a base http template.
The template text on the left is parsed into an object for further processing.

<FlexyCodeGrid>
```http title="http input"
POST http://origin/path?x=y
header: value

content
```
```json title="parsed"
{
  method: "POST",
  origin: "http://origin",
  pathname: "/path",
  searchParams:
    new URLSearchParams("?x=y"),
  headers:
    new Headers({ "header": "value" }),
  body: 'content'
}
```
</FlexyCodeGrid>

This parsed object data is then merged with a template that represents all http requests.

<FlexyCodeGrid>
```js title="parsed"
{
  method: "POST",
  origin: "http://service",
  pathname: "/path",
  searchParams:
    new URLSearchParams("?x=y"),
  headers:
    new Headers({ "header": "value" }),
  body: 'content'
}
```
```js title="template"
{
    method: "{{method}}",
    origin: "{{origin}}",
    pathname: "{{...pathname}}",
    searchParams: search = ...,

    headers: headers = ...,

    body: body = ...
}
```
</FlexyCodeGrid>

The body template _can be_ interpreted using the special template syntax, but it can also be treated
as url-encoded form data (that still supports interpolations), or plain text. {/* binary support is pending */}
The other values in an HTTP template only allow for `{{ ... }}`-style interpolations.

### HTTP Request and Response Bodies

The body template makes a best-guess on what encoding it has.  Some options are `text`, `raw`, `json` (includes script), and `form`.

A `Content-Type` header will help pardon guess about the type.

There is also a meta "header" which will override any guesses.  E.g.,
```
[body]: form
```

(Meta headers are not legal HTTP headers and are not sent).

If the body parses as `JSON` it is JSON, if the body parses as a script,
it is also `JSON`, unless it defines another encoding at the top level.
If the body doesn't parse, it is treated as "text", and interpolations still apply.

For example, we can define a form using either `form()` encoding or directly as text.
<FlexyCodeGrid centered>
```http
POST https://...


form({ a: 'b' })
```
```http
POST https://...
[body]: form

a=b&c=d
```
```http
POST https://...
Content-Type: x-www-form-urlencoded

a=b&c=d
```
</FlexyCodeGrid>

Specifying `[body]: raw`, for instance, turns off all template processing and sends the body exactly as is.

:::note
Some services require the `Content-Type` to be set, `[body]` is usually not necessary.
:::

# Next Steps

Explore Pardon's testcase generation system and HTTPS flows.

<CollectionLinkCard href="/intro/testcases" />

A deeper dive into the features and syntax transformations available in the template runtime.

<CollectionLinkCard href="/reference/template-runtime" />
